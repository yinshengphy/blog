---
title: RSA加密原理
toc: true
date: 2020-03-21 13:21:57
thumbnail: /assets/posts/rsa/rsa-logo.jpg
tags: 
- RSA
- 密码学
- 数论
categories:
- 随笔
---

**RSA**算法作为最著名的非对称加密算法,在网络安全中起到了至关重要的作用。可以说,没有**RSA**,现在网络的安全性将荡然无存。无论是你填写的密码,还是发送的私密信息.都有可能会被窃取,篡改。所以,让我们怀着朝圣般的敬意,让我们来探究一下**RSA**的秘密。

<!-- more -->

# 前言

## 背景
在1977年之前,所有的加密算法都是**对称加密算法**,即张三指定一种加密规则对需要传递的信息生成密文,李四按照相同的规则对传递过来的密文进行解密获得明文,也就是说,只要张三和李四是分别掌握了该条加密规则,且保证没有别人掌握该条加密规则,那么他们两个之间的信息交换永远是安全的。当然这只是理想情况,原因在于,谁也无法保证张三在偷偷告诉李四加密规则时候,有没有人旁听到该条加密规则,拓展到互联网络,就是在传递数据包之前,无法保证密钥传递时的安全性,我们总是悲观的认为每条信息都不是安全的,事实也确实如此,因为http协议本身就是不安全的  

那么有没有办法规避传递密钥是造成的安全问题呢？解决方案就是**RSA**

RSA是1977年由 **罗纳德·李维斯特（Ron Rivest）**、**阿迪·萨莫尔（Adi Shamir）**和**伦纳德·阿德曼（Leonard Adleman）**一起提出的。

当时他们三人都在麻省理工学院工作。**RSA**就是他们三人姓氏开头字母拼在一起组成的。

## 基本原理
让我们再回到张三李四互相交换信息的情景下,借助**RSA**,张三李四如何才能规避掉通过不安全网络传递密钥造成的密钥泄漏风险呢,答案是采用两套密钥,我们分别把他们叫做**公钥**和**私钥**,此时,公钥被放在公网环境中可以随意的被人下载使用,而私钥则被安全的保存在在张三手中。假设李四想与张三通信,李四会用张三提供在公网上的公钥加密自己的报文生成密文发送给张三,在传输过程中,即使密文被截获仍然不能破解得到明文报文,张三收到传递过来的密文后,用自己的私钥解密密文得到明文。整个过程中张三李四分别有着不同的密钥,这个加密方法就是非对称加密。

首先我们来了解一下这个加密解密的过程:

$$密文＝明文^E \\% N$$ $$明文＝密文^D \\% N$$

对于如上加解密过程,我们做出如下定义

|  名称   | 公式表示  |
| :---: | :---: |
| 公钥  | （E,N） |
| 私钥  | （D,N） |
| 密钥对  | （E,D,N） |
| 加密  | $密文＝明文^E \\% N$ |
| 解密  | $明文＝密文^D \\% N$ |

这样原理我们就弄清楚了,那么上文的**E**,**N**,**D**可以是随便的三个数吗？当然不是。

生成密钥对的过程论述需要一定的数论知识,下面就进入论证的过程

# 论证过程

## 相关理论

在所有论证过程开始之前,我们需要了解一下若干概念。

### 互质
如果两个正整数,除了1以外,没有其他公因子,我们就称这两个数是**互质关系（coprime）**。比如,15和32没有公因子,所以它们是互质关系。这说明,不是质数也可以构成互质关系。

### 欧拉函数
欧拉函数是数论中很重要的一个函数,欧拉函数是指：**对于一个正整数 n ,小于 n 且和 n 互质的正整数（包括 1）的个数**,记作 **φ(n)**

欧拉函数有一个通用展开式：

$φ(n)=n(1 - \frac 1b_1)(1 - \frac 1b_2)...(1 - \frac 1b_r)$

其中$n=p_1^{k1}p_2^{k2}...p_r^{kr}$

因为**任意一个大于1的正整数,都可以写成一系列质数的积**。

### 中国剩余定理（CRT）
中国剩余定理表述如下：(此处摘自[维基百科](https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86))

记：
$$
(S):
\left\lbrace 
\begin{matrix}
x\equiv a_1\pmod {m_1} \\\\
x\equiv a_2\pmod {m_2} \\\\
... \\\\
x\equiv a_n\pmod {m_n} \\\\
\end{matrix} 
\right.
$$

1. 设$M=m_1\times m_2\times ...\times m_n=\prod_{i=1}^nm_i$
2. 设$M_i=M/m_i$
3. 设$t_i为M_i模m_i$的[数论倒数](https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA%E5%80%92%E6%95%B0)
即$t_iM_i\equiv 1\pmod {m_i}$
4. 方程组(S)的通解形式为
$x=kM+\sum_{i=1}^na_it_iM_i$,  $k\in Z$
在模M的意义下,方程组方程组(S)只有一个解：$x=\sum_{i=1}^na_it_iM_i$

### 欧拉函数式积性函数证明
在此之前,还需要证明一个关于欧拉函数非常重要的特性

**φ(ab)=φ(b)φ(b)**,即欧拉函数式一个**积性函数**

证明如下：

有两个集合：
$A:\lbrace a: 1\leqslant a \leqslant mn,\quad   gcd(a,mn)=1 \rbrace $
**集合*A***共有**φ(mn)**个元素

$B:\lbrace (b,c):1\leqslant b \leqslant m,  \ gcd(b,m)=1 \quad,  \quad 1\leqslant c \leqslant n,  \ gcd(c,n)=1\rbrace$
**集合*B***共有**φ(m)×φ(n)**个元素

**中国剩余定理**告诉我们：
$$
(S):
\left\lbrace 
\begin{matrix}
a\equiv b\pmod m \\\\
a\equiv c\pmod n \\\\
\end{matrix} 
\right.
$$

该方程组**有且仅有一个解**,所以**集合*B***中的元素$(b,c)$和**集合*B***中的元素$(a)$是一一对应的([双射](https://zh.wikipedia.org/wiki/%E5%8D%95%E5%B0%84%E3%80%81%E5%8F%8C%E5%B0%84%E4%B8%8E%E6%BB%A1%E5%B0%84))
即：
```
φ(ab)=φ(b)φ(b)
```

### 欧拉函数通用展开式证明
下面是对欧拉函数通用计算公式的证明：
对于任何一个大于1的整数n,都可以写成一系列质数的乘积
记：$n=p_1^{k1}p_2^{k2}...p_r^{kr}$(**等式一**)

则：$φ(n)=φ(p_1^{k1}p_2^{k2}...p_r^{kr})=φ(p_1^{k1})φ(p_2^{k2})φ(p_r^{kr})$(**等式二**)

对于任意一个质数次方的欧拉函数$φ(p^k)$,我们可以采取排除发进行计算：
$\lbrace n|p^k>n>1且q \in N \rbrace$表示的正整数共有$p^k$个,而其中只有不包含**因子*p***的,才能和*n*互质,所以在$p^k$中,和*n*有公因子的数量为$p^{k-1}$,从而可以得出结论,$\lbrace n|p^k>n>1且q \in N \rbrace$中和*n*有**公因子p**的正整数数量为$p^{k-1}$
故：
$φ(p^k)=p^k-p^{k-1}$(**等式三**)

**等式一、二、三**联立,得：

$φ(n)=n(1 - \frac 1 p_1)(1 - \frac 1 p_2)...(1 - \frac 1 p_r)$


### 欧拉定理
对于互质的**正整数** a 和 n ,有 $a^{φ(n)} \equiv 1\pmod n$。

此外，如果*n*是一个**质数**，则有$a^{n-1} \equiv 1\pmod n$

上述公式是欧拉定理在**特殊情况**下(*n*是一个质数)的特殊形式，它有一个单独的名字：[费马小定理](https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86)

欧拉定理是**RSA算法**的核心。理解了这个定理，就可以理解**RSA**

### 数论倒数
数论倒数(number-theoretic reciprocal)亦称算术倒数，是与同余有关的一个基本概念。设m为模，a为任意整数，且(a，m)=1。若有整数a′能满足同余式$a′a\equiv 1\pmod m$，则称a′是$a\pmod m$的数论倒数，或逆元。

#### 数论倒数的求解
数论倒数的求解，我们可以换一种思路，我们对上述等式作简单变换，得：

$a′a-km=1\quad (k \in Z)$

即对于已知的，互质的整数 a,m 求二元一次方程，可能还是有点难看，我们再把它整理一下变得更像一个方程：

对于互质的整数a，b，求如下方程整数解，且欧拉定理告诉我们，如下方程一定有一个(对)解

$ax+by=1\quad (x,y \in Z)$

为了避免用暴力穷举法来求解，我们引入另一个算法：[欧几里得扩展算法](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)

求解及证明请大家自己查阅资料，这里我给出java求解函数

```java
public class EuclideanTest
{
    public static void main()
    {
        Tuple2<Integer, Integer> result = euclidean(3, -17);
        System.out.println(result.toString());
    }

    public Tuple2<Integer, Integer> euclidean(int a, int b)
    {
        if (b == 0)
            return new Tuple2<>(1, 0);
        else
        {
            Tuple2<Integer, Integer> result = euclidean(b, a % b);
            return new Tuple2<>(result.second, result.first - (a / b) * result.second);
        }

    }

    static class Tuple2<A, B>
    {

        public final A first;

        public final B second;

        public Tuple2(A a, B b)
        {
            first = a;
            second = b;
        }

        public String toString()
        {
            return "(" + first + ", " + second + ")";
        }

    }
}
```
由于java中没有**元组**的概念，这里我构建了一个类Tuple2来表示二元组

至此，所有RSA算法需要的数论知识都已介绍完毕，下面将介绍如何借助这些理论知识来生成我们的公钥和私钥

## 公钥私钥的生成及使用方法

### 公钥，私钥的获取
回顾一下前面的[基本原理](#基本原理)，我们知道公钥私钥就对应着**两对**二元组 **(E,N)**和**(D,N)**，加密解密的过程为：$$密文＝明文^E\pmod N$$$$明文＝密文^D\pmod N$$

#### 第一步：找到两个不相等质数
>其实找质数，在计算机发明出来之前，和计算圆周率一样，也是一个挺麻烦的事，尽管在分布式网络计算十分发达的现在，人类找到的最大质数也就是一个24,862,048位数。
&emsp;&emsp;说到找质数，我想到一个很有意思的典故，这个典故就是关于欧拉和费马的，这两个人我在上文中也提及过。费马是个业余数学家，但是他的爱好就是提出一些猜想，然后在纸上写上`关于此，我确信我发现了一种美妙的证法，可惜这里的空白处太小，写不下`,他的其中一个猜想就是费马数猜想。
&emsp;&emsp;费马数表述如下：具有形式($2^{2^n}+1$)的自然数，称为费马数，记做$F_n$，费马数猜想就是所有的费马数都是素数，因为费马验证了前四个都是正确的，这个猜想困扰了数学家们90余年还没得到证明，直到欧拉出现，他计算出费马数$F_5$,即：$$2^{2^5}+1=4294967297=641\times 6700417$$&emsp;&emsp;这个数是一个合数，emmm。
&emsp;&emsp;难道是这90余年数学家们都不肯多算一步吗，并不是，因为难点在于不是在于计算$2^{2^5}+1=4294967297$，而是在于计算$2^{2^5}+1=641\times 6700417$，即使在现在，我们还没有找到一个有效的算法来对一个对极大整数做因数分解，也只能不断地利用计算机进行暴力破解

我这里写了个简单程序来找到指定位数的质数
```java
public class FindPrime
{
    public static void main(String[] args)
    {
        System.out.println(findPrime3(2));
    }
    public List<Integer> findPrime3(int n)
    {
        List<Integer> primes = new ArrayList<>();
        if (n < 1)
        {
            return primes;
        }

        int start = (int) Math.pow(10, (n - 1));
        int end = (int) Math.pow(10, n) - 1;

        if (n == 1)
        {
            start = 2;
            primes.add(2);
        }

        for (int i = start + 1; i <= end; i += 2)
        {
            int tmp = (int) Math.sqrt(i) + 1;
            for (int j = 2; j <= tmp; j++)
            {
                if (i % j == 0)
                    break;
                if (j == tmp)
                    primes.add(i);
            }
        }
        return primes;
    }

}
```
结果是:\[**11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97**]
>实际上，选取位数越长的两个质数，该密钥对越难以破解，这里仅选了2位仅为方便说明原理，一般情况下我们会选取1024位的质数用以生成密钥对

这里我选取的是**41**和**71**，记做*p*和*q*

#### 第二步：计算两个质数的乘积
$$41 \times 71=2911$$

我们将结果**2911**记做$N$

#### 第三步：计算*N*的欧拉函数*φ(N)*
$$φ(n)=φ(pq)=φ(p)\times φ(q)=(p-1)\times (q-1)=40\times 70=2800$$

#### 第四步：找到一个介于($1$,$φ(N)$)之间,且与$φ(N)$互质的随机整数，记做$E$
这里我们随机选出**51**

#### 第五步：计算e关于$φ(n)$的数论倒数
数论倒数的概念及计算方法，我在上文也有所提及，这里我们直接运行[上面给出的程序](#数论倒数的求解)，输入参数(_51_, _2800_)，计算得到结果(_-549_, _10_)，其中，*10*为系数 *k*，我们不需要，而 **-549** 则是我们需要的数论倒数，但是，负数的数论倒数在RSA中是不被允许的，所以我们将其转化为正数，即$-549+2800=2251$，我们记做 **D**

至此，我们需要的公钥私钥生成完毕，代号也和文章开头的密钥加解密契合，我们记公钥为(**51**,**2911**),私钥为(**2251**,**2911**)

### 密钥使用演示及结果验算
我们先来个简单的演算，假定张三持有私钥，李四持有公钥，李四想告诉张三一个字母**U**，字母**U**对应的ascii码为**85**

首先，李四对明文加密$85^{51}\\% {2911}=724$，得到密文**724**
 
然后，张三收到密文用自己持有的密钥进行解密$724^{2251}\\% {2911}=85$，得到明文**85**

```javascript
System.out.println(BigInteger.valueOf(85).pow(51).mod(BigInteger.valueOf(2911)));
System.out.println(BigInteger.valueOf(724).pow(2251).mod(BigInteger.valueOf(2911)));
```

大家也可以自行验算一下

### 密钥安全性分析
前文我们有提及，私钥是掌握在张三手中的，而李四持有的公钥是暴露在公网环境中的，那么，是否可以通过暴露在公网环境中的公钥来推算出私钥呢？下面是相关的分析

假设王五准备来破解该密钥对

首先，相关加密解密过程中，共出现了如下几个数字 **p(41), q(71), N(2911), φ(N)(2800), E(51), D(2251)**

王五掌握的数字有 **E(51), N(2911)**

而这些数字又满足该等式：$ED \equiv 1\pmod φ(N)$

聪明的王五明白，只要算出$φ(N)$,就可以破解该密钥对

而$φ(N)$又是等于$(p-1)(q-1)$的，且N是等于$p\times q$的

于是，勤奋的王五开始从**1**开始，一个数字一个的尝试用N(2911)来除该数字，希望得到整数解，终于功夫不负有心人，他算出了$41\times71$等于N(2911)，从而成功的破解了该密钥对

但是如果我们当时生成密钥对时将**N**设置为**4294967297**(前面提到的费马数)或者这远比这更大的数呢，王五即使昼夜不停的算，也算不完了吧。。

所以，我们此时明白了，对极大整数做因数分解的难度决定了**RSA加密算法**的可靠性。换言之，对一极大整数做因数分解愈困难，**RSA加密算法**愈可靠。假如有人找到一种快速因数分解的算法的话，那么用**RSA加密算法**的信息的可靠性就会极度下降。

全文完。